"""Generate the final clean, grouped SVG output."""
from lxml import etree
from typing import List, Dict, Optional
from collections import Counter

from ..parsing.svg_parser import PathInfo
from ..utils.logger import get_logger

logger = get_logger(__name__)

SVG_NS = "http://www.w3.org/2000/svg"


class SVGGenerator:
    """Build a clean, hierarchically organized SVG document."""

    def __init__(self, config: dict):
        out_cfg = config.get("output", {})
        self.indent = out_cfg.get("indent", True)
        self.indent_spaces = out_cfg.get("indent_spaces", 2)
        self.add_metadata = out_cfg.get("add_metadata", True)
        self.add_group_ids = out_cfg.get("add_group_ids", True)
        self.promote_common_attrs = out_cfg.get("promote_common_attributes", True)

    def generate(
        self,
        groups: List[List[PathInfo]],
        hierarchy: Dict,
        svg_metadata: dict,
    ) -> str:
        """
        Generate final SVG string.

        Args:
            groups: List of path groups.
            hierarchy: Hierarchy dict from HierarchyDetector.
            svg_metadata: Original SVG attributes (viewBox, width, height).

        Returns:
            Clean SVG string.
        """
        # Create root SVG element
        nsmap = {None: SVG_NS}
        root = etree.Element("{%s}svg" % SVG_NS, nsmap=nsmap)

        # Set SVG attributes
        if svg_metadata.get("viewBox"):
            root.set("viewBox", svg_metadata["viewBox"])
        if svg_metadata.get("width"):
            root.set("width", svg_metadata["width"])
        if svg_metadata.get("height"):
            root.set("height", svg_metadata["height"])

        # Add metadata comment
        if self.add_metadata:
            comment = etree.Comment(
                " Generated by SVG Vectorizer | "
                f"{sum(len(g) for g in groups)} paths in {len(groups)} groups "
            )
            root.append(comment)

        roots = hierarchy.get("roots", list(range(len(groups))))
        children_map = hierarchy.get("children", {})

        for root_idx in roots:
            self._add_group_recursive(root, groups, root_idx, children_map)

        tree = etree.ElementTree(root)

        if self.indent:
            etree.indent(tree, space=" " * self.indent_spaces)

        svg_bytes = etree.tostring(
            root,
            pretty_print=self.indent,
            xml_declaration=True,
            encoding="utf-8",
        )
        svg_string = svg_bytes.decode("utf-8")

        logger.info(f"Generated SVG: {len(svg_string)} characters")
        return svg_string

    def _add_group_recursive(
        self,
        parent_elem: etree._Element,
        groups: List[List[PathInfo]],
        group_idx: int,
        children_map: Dict,
    ):
        """Recursively add a group and its children to the SVG tree."""
        if group_idx >= len(groups):
            return

        group = groups[group_idx]
        children = children_map.get(group_idx, [])

        if len(group) == 1 and not children:
            self._add_path_element(parent_elem, group[0])
            return

        g_elem = etree.SubElement(parent_elem, "{%s}g" % SVG_NS)

        if self.add_group_ids:
            g_elem.set("id", f"group_{group_idx}")

        common_fill = None
        if self.promote_common_attrs and group:
            common_fill = self._get_common_attribute(group, "fill")
            if common_fill:
                g_elem.set("fill", common_fill)

            common_opacity = self._get_common_attribute(group, "opacity")
            if common_opacity and common_opacity != "1.0":
                g_elem.set("opacity", common_opacity)

        for path in group:
            self._add_path_element(
                g_elem,
                path,
                promoted_fill=common_fill if self.promote_common_attrs else None,
            )

        for child_idx in children:
            self._add_group_recursive(g_elem, groups, child_idx, children_map)

    def _add_path_element(
        self,
        parent: etree._Element,
        path_info: PathInfo,
        promoted_fill: Optional[str] = None,
    ):
        """Add a single path element."""
        elem = etree.SubElement(parent, "{%s}path" % SVG_NS)
        elem.set("d", path_info.d)

        if promoted_fill is None or path_info.fill != promoted_fill:
            elem.set("fill", path_info.fill)

        if path_info.stroke != "none":
            elem.set("stroke", path_info.stroke)

        if path_info.opacity != 1.0:
            elem.set("opacity", str(path_info.opacity))

        if path_info.transform:
            elem.set("transform", path_info.transform)

    @staticmethod
    def _get_common_attribute(group: List[PathInfo], attr: str) -> Optional[str]:
        """
        Check if all paths in a group share the same value for an attribute.
        Returns the common value, or None if values differ.
        """
        values = []
        for p in group:
            if attr == "fill":
                values.append(p.fill)
            elif attr == "opacity":
                values.append(str(p.opacity))
            elif attr == "stroke":
                values.append(p.stroke)

        if not values:
            return None

        counter = Counter(values)
        most_common_val, most_common_count = counter.most_common(1)[0]

        if most_common_count == len(values):
            return most_common_val

        return None
